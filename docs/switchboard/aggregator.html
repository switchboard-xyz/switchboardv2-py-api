<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>switchboard.aggregator API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>switchboard.aggregator</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations

import struct
import anchorpy
import time
import hashlib

from dataclasses import dataclass
from decimal import Decimal
from typing import Optional, Any, NamedTuple

from solana.keypair import Keypair
from solana.publickey import PublicKey
from spl.token.async_client import AsyncToken
from spl.token.constants import TOKEN_PROGRAM_ID
from solana.transaction import TransactionSignature
from spl.token.instructions import get_associated_token_address
from solana.system_program import CreateAccountParams, create_account

from switchboard.compiled import OracleJob
from switchboard.common import AccountParams, SwitchboardDecimal
from switchboard.program import ProgramStateAccount
from switchboard.oraclequeue import OracleQueueAccount
from switchboard.oracle import OracleAccount
from switchboard.job import JobAccount
from switchboard.lease import LeaseAccount
from switchboard.permission import PermissionAccount

# Parameters for which oracles must submit for responding to update requests.
@dataclass
class AggregatorSaveResultParams:

    &#34;&#34;&#34;Index in the list of oracles in the aggregator assigned to this round update.&#34;&#34;&#34;
    oracle_idx: int

    &#34;&#34;&#34;Reports that an error occured and the oracle could not send a value.&#34;&#34;&#34;
    error: bool

    &#34;&#34;&#34;Value the oracle is responding with for this update.&#34;&#34;&#34;
    value: Decimal

    &#34;&#34;&#34;
    The minimum value this oracle has seen this round for the jobs listed in the
    aggregator.
    &#34;&#34;&#34;
    min_response: Decimal

    &#34;&#34;&#34;
    The maximum value this oracle has seen this round for the jobs listed in the
    aggregator.
    &#34;&#34;&#34;
    max_response: Decimal

    &#34;&#34;&#34;List of OracleJobs that were performed to produce this result&#34;&#34;&#34;
    jobs: list[OracleJob]

    &#34;&#34;&#34;Authority of the queue the aggregator is attached to&#34;&#34;&#34;
    queue_authority: PublicKey

    &#34;&#34;&#34;Program token mint&#34;&#34;&#34;
    token_mint: PublicKey

    &#34;&#34;&#34;List of parsed oracles&#34;&#34;&#34;
    oracles: list[Any]

# Parameters for creating and setting a history buffer
@dataclass
class AggregatorSetHistoryBufferParams:
    
    &#34;&#34;&#34;Number of elements for the history buffer to fit&#34;&#34;&#34;
    size: int

    &#34;&#34;&#34;Authority keypair for the aggregator&#34;&#34;&#34;
    authority: Keypair = None

# Parameters required to open an aggregator round
@dataclass
class AggregatorOpenRoundParams:

    &#34;&#34;&#34;The oracle queue from which oracles are assigned this update.&#34;&#34;&#34;
    oracle_queue_account: OracleQueueAccount
    
    &#34;&#34;&#34;The token wallet which will receive rewards for calling update on this feed.&#34;&#34;&#34;
    payout_wallet: PublicKey


# Init Params for Aggregators
@dataclass
class AggregatorInitParams(NamedTuple):
    &#34;&#34;&#34;Number of oracles to request on aggregator update.&#34;&#34;&#34;
    batch_size: int

    &#34;&#34;&#34;Minimum number of oracle responses required before a round is validated.&#34;&#34;&#34;
    min_required_oracle_results: int

    &#34;&#34;&#34;Minimum number of seconds required between aggregator rounds.&#34;&#34;&#34;
    min_required_job_results: int

    &#34;&#34;&#34;Minimum number of seconds required between aggregator rounds.&#34;&#34;&#34;
    min_update_delay_seconds: int

    &#34;&#34;&#34;The queue to which this aggregator will be linked&#34;&#34;&#34;
    queue_account: OracleQueueAccount
 
    &#34;&#34;&#34;Name of the aggregator to store on-chain.&#34;&#34;&#34;
    name: bytes = None

    &#34;&#34;&#34;Metadata of the aggregator to store on-chain.&#34;&#34;&#34;
    metadata: bytes = None

    &#34;&#34;&#34;unix_timestamp for which no feed update will occur before.&#34;&#34;&#34;
    start_after: int = None

    &#34;&#34;&#34;
    Change percentage required between a previous round and the current round.
    If variance percentage is not met, reject new oracle responses.
    &#34;&#34;&#34;
    variance_threshold: Decimal = None

    &#34;&#34;&#34;
    Number of seconds for which, even if the variance threshold is not passed,
    accept new responses from oracles.
    &#34;&#34;&#34;
    force_report_period: int = None

    &#34;&#34;&#34;
    unix_timestamp after which funds may be withdrawn from the aggregator.
    null/undefined/0 means the feed has no expiration.
    &#34;&#34;&#34;
    expiration: int = None

    &#34;&#34;&#34;
    An optional wallet for receiving kickbacks from job usage in feeds.
    Defaults to token vault.
    &#34;&#34;&#34;
    keypair: Keypair = None
    
    &#34;&#34;&#34;
    An optional wallet for receiving kickbacks from job usage in feeds.
    Defaults to token vault.
    &#34;&#34;&#34;
    author_wallet: PublicKey = None

    &#34;&#34;&#34;
    If included, this keypair will be the aggregator authority rather than
    the aggregator keypair.
    &#34;&#34;&#34;
    authority: PublicKey = None


@dataclass
class AggregatorHistoryRow:
    &#34;&#34;&#34;AggregatorHistoryRow is a wrapper for the row structure of elements in the aggregator history buffer.
    
    Attributes:
        timestamp (int): timestamp of the aggregator result
        value (Decimal): Aggregator value at the timestamp
    &#34;&#34;&#34;
    timestamp: int
    value: Decimal
    
    &#34;&#34;&#34;
    Generate an AggregatorHistoryRow from a retrieved buffer representation

    Args:
        buf (list): Anchor-loaded buffer representation of AggregatorHistoryRow

    Returns:
        AggregatorHistoryRow
    &#34;&#34;&#34;
    @staticmethod
    def from_buffer(buf: bytes):
        timestamp: int = struct.unpack_from(&#34;&lt;L&#34;, buf[:8])[0]
        mantissa: int = struct.unpack_from(&#34;&lt;L&#34;, buf[8:24])[0]
        scale: int = struct.unpack_from(&#34;&lt;L&#34;, buf, 24)[0]
        decimal = SwitchboardDecimal.sbd_to_decimal({&#34;mantissa&#34;: mantissa, &#34;scale&#34;: scale})
        res = AggregatorHistoryRow(timestamp, decimal)
        return res


class AggregatorAccount:
    &#34;&#34;&#34;AggregatorAccount is the wrapper for an Aggregator, the structure for that keeps aggregated feed data / metadata.

    Attributes:
        program (anchor.Program): The anchor program ref
        public_key (PublicKey | None): This aggregator&#39;s public key
        keypair (Keypair | None): this aggregator&#39;s keypair
    &#34;&#34;&#34;


    def __init__(self, params: AccountParams):
        if params.public_key is None and params.keypair is None:
            raise ValueError(&#39;User must provide either a publicKey or keypair for account use.&#39;)
        if params.keypair and params.public_key and params.keypair.public_key != params.public_key:
            raise ValueError(&#39;User must provide either a publicKey or keypair for account use.&#39;)
        self.program = params.program
        self.public_key = params.keypair.public_key if params.keypair else params.public_key
        self.keypair = params.keypair
        

    &#34;&#34;&#34;
    Get name of an aggregator.

    Args:
        aggregator (Any): Anchor-loaded aggregator

    Returns:
        name string of the aggregator
    &#34;&#34;&#34;
    @staticmethod
    def get_name(aggregator: Any) -&gt; str:
        return  &#39;&#39;.join(map(chr, *aggregator.name)).decode(&#34;utf-8&#34;).replace(u&#34;\u0000&#34;, &#34;*&#34;).encode(&#34;utf-8&#34;)

        
    &#34;&#34;&#34;
    Load and parse AggregatorAccount state based on the program IDL. 
    
    Returns:
        name (AggregatorAccount): data parsed in accordance with the
            Switchboard IDL.

    Args:

    Raises:
        AccountDoesNotExistError: If the account doesn&#39;t exist.
        AccountInvalidDiscriminator: If the discriminator doesn&#39;t match the IDL.
    &#34;&#34;&#34;
    async def load_data(self):
        aggregator = await self.program.account[&#34;AggregatorAccountData&#34;].fetch(self.public_key)
        aggregator.ebuf = None
        return aggregator

    &#34;&#34;&#34;
    Get AggregatorAccount historical data 

    Returns:
        name (AggregatorAccount): data parsed in accordance with the
            Switchboard IDL.

    Args:
        aggregator (Any): Optional aggregator 

    Raises:
        AccountDoesNotExistError: If the account doesn&#39;t exist.
        AccountInvalidDiscriminator: If the discriminator doesn&#39;t match the IDL.
    &#34;&#34;&#34;
    async def load_history(self, aggregator: Any = None) -&gt; Any:

        # if aggregator data passed in - use that, else load this aggregator
        aggregator = aggregator if aggregator else await self.load_data()

        # Compare History Buffer to default public key (zeroed out)
        if (aggregator.history_buffer == 11111111111111111111111111111111):
            return []

        # Fixed AggregatorHistoryRow size
        ROW_SIZE = 28

        # Get account data
        info = await self.program.provider.connection.get_account_info(aggregator.history_buffer) 
        buffer = info.data if info else []
        if not buffer or buffer.length &lt; 12:
            return []
        
        # Read UInt32 as a Little Endian val, starting at position 8
        insert_idx: int = struct.unpack_from(&#34;&lt;L&#34;, buffer, 8)[0] * ROW_SIZE

        front = []
        tail = []

        if not isinstance(buffer, list):
            return []
        
        for i in range(13, buffer.length, ROW_SIZE):
            if i + ROW_SIZE &gt; buffer.length:
                break
            row = AggregatorHistoryRow.fromBuffer(buffer)
            if row.timestamp == 0:
                break
            if i &lt;= insert_idx:
                tail.append(row)
            else:
                front.append(row)
        return front.extend(tail)

    &#34;&#34;&#34;
    Get the latest confirmed value stored in the aggregator account. 
    
    Args:
        aggregator (Any): Optional aggregator value to pass in

    Returns:
        value (Decimal): the latest feed value

    Raises:
        ValueError: If the aggregator currently holds no value
        AccountDoesNotExistError: If the account doesn&#39;t exist.
        AccountInvalidDiscriminator: If the discriminator doesn&#39;t match the IDL.
    &#34;&#34;&#34;
    async def get_latest_value(self, aggregator: Optional[Any] = None) -&gt; Decimal:
        aggregator = aggregator if aggregator else await self.load_data()
        if hasattr(aggregator, &#39;latest_confirmed_round&#39;) and aggregator.latest_confirmed_round.num_success == 0:
            raise ValueError(&#39;Aggregator currently holds no value.&#39;)
        return SwitchboardDecimal.sbd_to_decimal(aggregator.latest_confirmed_round.result)


    &#34;&#34;&#34;
    Get the timestamp latest confirmed round stored in the aggregator account. 
    
    Args:
        aggregator (Any): Optional aggregator value to pass in

    Returns:
        timestamp (str): latest feed timestamp as hex string

    Raises:
        ValueError: If the aggregator currently holds no value
        AccountDoesNotExistError: If the account doesn&#39;t exist.
        AccountInvalidDiscriminator: If the discriminator doesn&#39;t match the IDL.
    &#34;&#34;&#34;
    async def get_latest_feed_timestamp(self, aggregator: Any) -&gt; Decimal:
        aggregator = aggregator if aggregator else await self.load_data()
        if hasattr(aggregator, &#39;latest_confirmed_round&#39;) and aggregator.latest_confirmed_round.num_success == 0:
            raise ValueError(&#39;Aggregator currently holds no value.&#39;)

        return aggregator.latest_confirmed_round.round_open_timestamp


    &#34;&#34;&#34;
    Get name of an aggregator.

    Args:
        aggregator (any): Anchor-loaded aggregator

    Returns:
        name string of the aggregator
    &#34;&#34;&#34;
    @staticmethod
    def should_report_value(value: Decimal, aggregator: Any) -&gt; bool:
        if aggregator.latestConfirmedRound and aggregator.latest_confirmed_round.num_success == 0:
            return True
        timestamp = round(int(time.time()) / 1000)
        if aggregator.start_after &gt; timestamp:
            return False
        variance_threshold = SwitchboardDecimal.sbd_to_decimal(aggregator.variance_threshold)
        latest_result = SwitchboardDecimal.sbd_to_decimal(aggregator.latest_confirmed_round.result)
        force_report_period = aggregator.force_report_period
        last_timestamp = aggregator.latest_confirmed_round.round_open_timestamp
        if last_timestamp + force_report_period &lt; timestamp:
            return True
        if value &lt; latest_result - variance_threshold:
            return True
        if value &gt; latest_result + variance_threshold:
            return True
        return False

    &#34;&#34;&#34;
    Get the individual oracle results of the latest confirmed round. 
    
    Args:
        aggregator (Any): Optional aggregator value to pass in

    Returns:
        timestamp (str): latest feed timestamp as hex string

    Raises:
        ValueError: If aggregator currently holds no value.
    &#34;&#34;&#34;
    async def get_confirmed_round_results(self, aggregator: Any) -&gt; Decimal:
        
        aggregator = aggregator if aggregator else await self.load_data()
        if hasattr(aggregator, &#39;latest_confirmed_round&#39;) and aggregator.latest_confirmed_round.num_success == 0:
            raise ValueError(&#39;Aggregator currently holds no value.&#39;)
        results: list[Any] = []
        for i in range(aggregator.oracle_request_batch_size):
            if aggregator.latest_confirmed_round.medians_filfilled[i]:
                results.append({
                    &#34;oracle_account&#34;: OracleAccount(self.program, aggregator.latest_confirmed_round.oracle_pubkeys_data[i]),
                    &#34;value&#34;: SwitchboardDecimal.sbd_to_decimal(aggregator.latest_confirmed_round.medians_data[i])
                })
        return results

    &#34;&#34;&#34;
    Get the hash of a list of OracleJobs
    
    Args:
        jobs (list[OracleJob]): list of jobs to hash

    Returns:
        hash (_Hash): hash as hex string

    Raises:
    &#34;&#34;&#34;
    @staticmethod
    def produce_job_hash(jobs: list[OracleJob]):
        hash = hashlib.sha256()
        for job in jobs:
            job_hasher = hashlib.sha256()
            job_hasher.update(job.SerializeToString())
            hash.update(job_hasher.digest())
        return hash


    &#34;&#34;&#34;
    Load and deserialize all jobs stored in this aggregator
    
    Args:
        aggregator (Any): Optional aggregator

    Returns:
        jobs (list[OracleJob]): latest feed timestamp as hex string

    Raises:
        ValueError: Failed to load feed jobs.
        AccountDoesNotExistError: If the account doesn&#39;t exist.
        AccountInvalidDiscriminator: If the discriminator doesn&#39;t match the IDL.
    &#34;&#34;&#34;
    async def load_jobs(self, aggregator: Any) -&gt; Decimal:
        coder = anchorpy.AccountsCoder(self.program.idl);
        aggregator = aggregator if aggregator else await self.load_data()
        job_accounts_raw = await anchorpy.utils.rpc.get_multiple_accounts(self.program.provider, aggregator.job_pubkeys_data)[:aggregator.job_pubkeys_size]
        if not job_accounts_raw:
            raise ValueError(&#39;Failed to load feed jobs.&#39;)
        
        # Deserialize OracleJob objects from each decoded JobAccountData 
        return [OracleJob.ParseFromString(coder.decode(job)) for job in job_accounts_raw]
        
    &#34;&#34;&#34;
    Load all job hashes for each job stored in this aggregator
    
    Args:
        aggregator (Any): Optional aggregator

    Returns:
        hashes (list[str]): hashes for each job 

    Raises:
        AccountDoesNotExistError: If the account doesn&#39;t exist.
        AccountInvalidDiscriminator: If the discriminator doesn&#39;t match the IDL.
    &#34;&#34;&#34;
    async def load_hashes(self, aggregator: Any) -&gt; Decimal:
        coder = anchorpy.AccountsCoder(self.program.idl);
        aggregator = aggregator if aggregator else await self.loadData()
        job_accounts_raw = await anchorpy.utils.rpc.get_multiple_accounts(self.program.provider, aggregator.job_pubkeys_data)[:aggregator.job_pubkeys_size]
        if not job_accounts_raw:
            raise ValueError(&#39;Failed to load feed jobs.&#39;)
        
        # get hashes from each decoded JobAccountData 
        return [coder.decode(job).hash for job in job_accounts_raw]
        
    
    &#34;&#34;&#34;
    Get the size of an AggregatorAccount on chain
    
    Returns:
        int: size of the AggregatorAccount on chain
    &#34;&#34;&#34;
    def size(self):
        return self.program.account[&#34;AggregatorAccountData&#34;].size

    &#34;&#34;&#34;
    Create and initialize the AggregatorAccount.
    
    Args:
        program (anchorpy.Program): Switchboard program representation holding connection and IDL
        params (AggregatorInitParams): init params for the aggregator

    Returns:
        AggregatorAccount
    &#34;&#34;&#34;
    @staticmethod
    async def create(program: anchorpy.Program, aggregator_init_params: AggregatorInitParams):
        aggregator_account = aggregator_init_params.keypair or Keypair.generate()
        authority = aggregator_init_params.authority or aggregator_account.public_key
        size = program.account[&#34;AggregatorAccountData&#34;].size
        state_account, state_bump = ProgramStateAccount.from_seed(program)
        state = await state_account.load_data()
        lamports = await program.provider.connection.get_minimum_balance_for_rent_exemption(size)
        await program.rpc[&#34;aggregator_init&#34;](
            {
                &#34;name&#34;: aggregator_init_params.name or bytes([0] * 32),
                &#34;metadata&#34;: aggregator_init_params.metadata or bytes([0] * 128),
                &#34;batch_size&#34;: aggregator_init_params.batch_size,
                &#34;min_oracle_results&#34;: aggregator_init_params.min_required_oracle_results,
                &#34;min_job_results&#34;: aggregator_init_params.min_required_job_results,
                &#34;variance_threshold&#34;: aggregator_init_params.variance_threshold or 0,
                &#34;force_report_period&#34;: aggregator_init_params.force_report_period or 0,
                &#34;expiration&#34;: aggregator_init_params.expiration or 0,
                &#34;state_bump&#34;: state_bump
            },
            ctx=anchorpy.Context(
                accounts={
                    &#34;aggregator&#34;: aggregator_account.public_key,
                    &#34;authority&#34;: authority,
                    &#34;queue&#34;: aggregator_init_params.queue_account.public_key,
                    &#34;author_wallet&#34;: aggregator_init_params.author_wallet or state.token_vault,
                    &#34;program_state&#34;: state_account.public_key
                },
                signers=[aggregator_account],
                instructions=[
                    create_account(
                        CreateAccountParams(
                            from_pubkey=program.provider.wallet.public_key, 
                            new_account_pubkey=aggregator_account.public_key,
                            lamports=lamports, 
                            space=size, 
                            program_id=program.program_id
                        )
                    )
                ]
            )
        )
        return AggregatorAccount(AccountParams(program=program, keypair=aggregator_account))

    &#34;&#34;&#34;
    Create and set a history buffer for the aggregator

    Args:
        program (anchorpy.Program): Switchboard program representation holding connection and IDL
        params (AggregatorSetHistoryBufferParams)

    Returns:
        TransactionSignature
    &#34;&#34;&#34;
    async def set_history_buffer(self, params: AggregatorSetHistoryBufferParams):
        buffer = Keypair.generate()
        program = self.program
        authority = params.authority or self.keypair
        HISTORY_ROW_SIZE = 28
        INSERT_IDX_SIZE = 4
        DISCRIMINATOR_SIZE = 8
        size = params.size * HISTORY_ROW_SIZE + INSERT_IDX_SIZE + DISCRIMINATOR_SIZE
        lamports = await program.provider.connection.get_minimum_balance_for_rent_exemption(size)

        await program.rpc[&#34;aggregator_set_history_buffer&#34;](
            {},
            ctx=anchorpy.Context(
                accounts={
                    &#34;aggregator&#34;: self.public_key,
                    &#34;authority&#34;: authority.public_key,
                    &#34;buffer&#34;: buffer.public_key
                },
                signers=[authority, buffer],
                instructions=[
                    create_account(
                        CreateAccountParams(
                            from_pubkey=program.provider.wallet.public_key,
                            new_account_pubkey=buffer.public_key,
                            space=size,
                            lamports=lamports,
                            program_id=program.program_id
                        )
                    )
                ]
            )
        )
    
    &#34;&#34;&#34;
    RPC to add a new job to an aggregtor to be performed on feed updates.

    Args:
        job (JobAccount): specifying another job for this aggregator to fulfill on update
        authority (Keypair | None)
    Returns:
        TransactionSignature
    &#34;&#34;&#34;
    async def add_job(self, job: JobAccount, authority: Optional[Keypair] = None) -&gt; TransactionSignature:
        authority = authority or self.keypair
        return await self.program.rpc[&#39;aggregator_add_job&#39;](
            ctx=anchorpy.Context(
                accounts={
                    &#34;aggregator&#34;: self.public_key,
                    &#34;authority&#34;: authority.public_key,
                    &#34;job&#34;: job.public_key
                },
                signers=[authority]
            )
        )
        
    &#34;&#34;&#34;
    Prevent new jobs from being added to the feed.

    Args:
        authority (Keypair | None): the current authority keypair

    Returns:
        TransactionSignature
    &#34;&#34;&#34;
    async def lock(self, authority: Optional[Keypair] = None) -&gt; TransactionSignature:
        authority = authority or self.keypair
        return await self.program.rpc[&#39;aggregator_lock&#39;](
            ctx=anchorpy.Context(
                accounts={
                    &#34;aggregator&#34;: self.public_key,
                    &#34;authority&#34;: authority.public_key,
                },
                signers=[authority]
            )
        )

    &#34;&#34;&#34;
    Change the aggregator authority

    Args:
        new_authority (Keypair): The new authority
        current_authority (Keypair | None): the current authority keypair

    Returns:
        TransactionSignature
    &#34;&#34;&#34;
    async def set_authority(self, new_authority: Keypair, current_authority: Optional[Keypair] = None) -&gt; TransactionSignature:
        current_authority = current_authority or self.keypair
        return await self.program.rpc[&#39;aggregator_set_authoirty&#39;](
            ctx=anchorpy.Context(
                accounts={
                    &#34;aggregator&#34;: self.public_key,
                    &#34;new_authority&#34;: new_authority,
                    &#34;authority&#34;: current_authority.public_key,
                },
                signers=[current_authority]
            )
        )

    &#34;&#34;&#34;
    RPC to add remove job from an aggregtor.

    Args:
        job (JobAccount): specifying job to remove
        authority (Keypair | None)
    Returns:
        TransactionSignature
    &#34;&#34;&#34;
    async def remove_job(self, job: JobAccount, authority: Optional[Keypair] = None) -&gt; TransactionSignature:
        authority = authority or self.keypair
        return await self.program.rpc[&#39;aggregator_remove_job&#39;](
            ctx=anchorpy.Context(
                accounts={
                    &#34;aggregator&#34;: self.public_key,
                    &#34;authority&#34;: authority.public_key,
                    &#34;job&#34;: job.public_key
                },
                signers=[authority]
            )
        )
    
    &#34;&#34;&#34;
    Get Index of Oracle in Aggregator

    Args:
        oracle_pubkey (PublicKey): Public key belonging to the oracle

    Returns:
        int: index of the oracle, -1 if not found
    &#34;&#34;&#34;
    async def get_oracle_index(self, oracle_pubkey: PublicKey):
        aggregator = await self.load_data()
        for i, curr_oracle_pubkey in enumerate(aggregator.current_round.oracle_pubkeys_data):
            if curr_oracle_pubkey == oracle_pubkey:
                return i
        return -1
    
    &#34;&#34;&#34;
    Save Aggregator result

    Args:
        aggregator (Any): Aggregator data
        oracle_account (OracleAccount)
        params (AggregatorSaveResultParams)

    Returns:
        TransactionSignature
    &#34;&#34;&#34;
    async def remove_job(self, aggregator: Any, oracle_account: OracleAccount, params: AggregatorSaveResultParams) -&gt; TransactionSignature:
        return await self.program.provider.send(
            tx=(
                await self.save_result_txn(
                    aggregator,
                    oracle_account,
                    params
                )
            )
        )
    
    &#34;&#34;&#34;
    RPC call for an oracle to save a result to an aggregator round.

    Args:
        aggregator (Any): Aggregator data
        oracle_account (OracleAccount)
        params (AggregatorSaveResultParams)

    Returns:
        TransactionSignature
    &#34;&#34;&#34;
    async def save_result_txn(self, aggregator: Any, oracle_account: OracleAccount, params: AggregatorSaveResultParams):
        payer_keypair = Keypair.from_secret_key(self.program.provider.wallet.payer.secret_key)
        remaining_accounts: list[PublicKey] = []
        for i in range(aggregator.oracle_request_batch_size):
            remaining_accounts.append(aggregator.current_round.oracle_pubkeys_data[i])
        for oracle in params.oracles:
            remaining_accounts.push(oracle.token_account)
        queue_pubkey = aggregator.queue_pubkey
        queue_account = OracleQueueAccount(AccountParams(program=self.program, public_key=queue_pubkey))
        lease_account, lease_bump = LeaseAccount.from_seed(
            self.program,
            queue_account,
            self
        )
        escrow = get_associated_token_address(lease_account.public_key, params.token_mint)
        feed_permission_account, feed_permission_bump = PermissionAccount.from_seed(
            self.program,
            params.queue_authority,
            queue_account.public_key,
            self.public_key
        )
        oracle_permission_account, oracle_permission_bump = PermissionAccount.from_seed(
            self.program,
            params.queue_authority,
            queue_account.public_key,
            oracle_account.public_key
        )
        program_state_account, state_bump = ProgramStateAccount.from_seed(self.program)
        digest = await self.produce_job_hash(params.jobs).digest()
        history_buffer = aggregator.history_buffer
        if history_buffer == PublicKey(&#39;11111111111111111111111111111111&#39;):
            history_buffer = self.public_key
        return self.program.transaction[&#39;aggregator_save_result&#39;](
            {
                &#34;oracle_idx&#34;: params.oracle_idx,
                &#34;error&#34;: params.error,
                &#34;value&#34;: SwitchboardDecimal.from_decimal(params.value), # @FIXME - verify that this decimal approach is correct (it very well might not be)
                &#34;jobs_checksum&#34;: digest,
                &#34;min_response&#34;: SwitchboardDecimal.from_decimal(params.min_response), # @FIXME
                &#34;max_response&#34;: SwitchboardDecimal.from_decimal(params.max_response), # @FIXME 
                &#34;feed_permission_bump&#34;: feed_permission_bump,
                &#34;oracle_permission_bump&#34;: oracle_permission_bump,
                &#34;lease_bump&#34;: lease_bump,
                &#34;state_bump&#34;: state_bump
            },
            ctx=anchorpy.Context(
                accounts={
                    &#34;aggregator&#34;: self.public_key,
                    &#34;oracle&#34;: oracle_account.public_key,
                    &#34;oracle_authority&#34;: payer_keypair.public_key,
                    &#34;oracle_queue&#34;: queue_account.public_key,
                    &#34;feed_permission&#34;: feed_permission_account.public_key,
                    &#34;oracle_permission&#34;: oracle_permission_account.public_key,
                    &#34;lease&#34;: lease_account.public_key,
                    &#34;escrow&#34;: escrow,
                    &#34;token_program&#34;: TOKEN_PROGRAM_ID,
                    &#34;program_state&#34;: program_state_account.public_key,
                    &#34;history_buffer&#34;: history_buffer
                },
                remaining_accounts=[{&#34;is_signer&#34;: False, &#34;is_writable&#34;: True, &#34;pubkey&#34;: pubkey} for pubkey in remaining_accounts]
            )
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="switchboard.aggregator.AggregatorAccount"><code class="flex name class">
<span>class <span class="ident">AggregatorAccount</span></span>
<span>(</span><span>params:Â AccountParams)</span>
</code></dt>
<dd>
<div class="desc"><p>AggregatorAccount is the wrapper for an Aggregator, the structure for that keeps aggregated feed data / metadata.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>program</code></strong> :&ensp;<code>anchor.Program</code></dt>
<dd>The anchor program ref</dd>
</dl>
<p>public_key (PublicKey | None): This aggregator's public key
keypair (Keypair | None): this aggregator's keypair</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AggregatorAccount:
    &#34;&#34;&#34;AggregatorAccount is the wrapper for an Aggregator, the structure for that keeps aggregated feed data / metadata.

    Attributes:
        program (anchor.Program): The anchor program ref
        public_key (PublicKey | None): This aggregator&#39;s public key
        keypair (Keypair | None): this aggregator&#39;s keypair
    &#34;&#34;&#34;


    def __init__(self, params: AccountParams):
        if params.public_key is None and params.keypair is None:
            raise ValueError(&#39;User must provide either a publicKey or keypair for account use.&#39;)
        if params.keypair and params.public_key and params.keypair.public_key != params.public_key:
            raise ValueError(&#39;User must provide either a publicKey or keypair for account use.&#39;)
        self.program = params.program
        self.public_key = params.keypair.public_key if params.keypair else params.public_key
        self.keypair = params.keypair
        

    &#34;&#34;&#34;
    Get name of an aggregator.

    Args:
        aggregator (Any): Anchor-loaded aggregator

    Returns:
        name string of the aggregator
    &#34;&#34;&#34;
    @staticmethod
    def get_name(aggregator: Any) -&gt; str:
        return  &#39;&#39;.join(map(chr, *aggregator.name)).decode(&#34;utf-8&#34;).replace(u&#34;\u0000&#34;, &#34;*&#34;).encode(&#34;utf-8&#34;)

        
    &#34;&#34;&#34;
    Load and parse AggregatorAccount state based on the program IDL. 
    
    Returns:
        name (AggregatorAccount): data parsed in accordance with the
            Switchboard IDL.

    Args:

    Raises:
        AccountDoesNotExistError: If the account doesn&#39;t exist.
        AccountInvalidDiscriminator: If the discriminator doesn&#39;t match the IDL.
    &#34;&#34;&#34;
    async def load_data(self):
        aggregator = await self.program.account[&#34;AggregatorAccountData&#34;].fetch(self.public_key)
        aggregator.ebuf = None
        return aggregator

    &#34;&#34;&#34;
    Get AggregatorAccount historical data 

    Returns:
        name (AggregatorAccount): data parsed in accordance with the
            Switchboard IDL.

    Args:
        aggregator (Any): Optional aggregator 

    Raises:
        AccountDoesNotExistError: If the account doesn&#39;t exist.
        AccountInvalidDiscriminator: If the discriminator doesn&#39;t match the IDL.
    &#34;&#34;&#34;
    async def load_history(self, aggregator: Any = None) -&gt; Any:

        # if aggregator data passed in - use that, else load this aggregator
        aggregator = aggregator if aggregator else await self.load_data()

        # Compare History Buffer to default public key (zeroed out)
        if (aggregator.history_buffer == 11111111111111111111111111111111):
            return []

        # Fixed AggregatorHistoryRow size
        ROW_SIZE = 28

        # Get account data
        info = await self.program.provider.connection.get_account_info(aggregator.history_buffer) 
        buffer = info.data if info else []
        if not buffer or buffer.length &lt; 12:
            return []
        
        # Read UInt32 as a Little Endian val, starting at position 8
        insert_idx: int = struct.unpack_from(&#34;&lt;L&#34;, buffer, 8)[0] * ROW_SIZE

        front = []
        tail = []

        if not isinstance(buffer, list):
            return []
        
        for i in range(13, buffer.length, ROW_SIZE):
            if i + ROW_SIZE &gt; buffer.length:
                break
            row = AggregatorHistoryRow.fromBuffer(buffer)
            if row.timestamp == 0:
                break
            if i &lt;= insert_idx:
                tail.append(row)
            else:
                front.append(row)
        return front.extend(tail)

    &#34;&#34;&#34;
    Get the latest confirmed value stored in the aggregator account. 
    
    Args:
        aggregator (Any): Optional aggregator value to pass in

    Returns:
        value (Decimal): the latest feed value

    Raises:
        ValueError: If the aggregator currently holds no value
        AccountDoesNotExistError: If the account doesn&#39;t exist.
        AccountInvalidDiscriminator: If the discriminator doesn&#39;t match the IDL.
    &#34;&#34;&#34;
    async def get_latest_value(self, aggregator: Optional[Any] = None) -&gt; Decimal:
        aggregator = aggregator if aggregator else await self.load_data()
        if hasattr(aggregator, &#39;latest_confirmed_round&#39;) and aggregator.latest_confirmed_round.num_success == 0:
            raise ValueError(&#39;Aggregator currently holds no value.&#39;)
        return SwitchboardDecimal.sbd_to_decimal(aggregator.latest_confirmed_round.result)


    &#34;&#34;&#34;
    Get the timestamp latest confirmed round stored in the aggregator account. 
    
    Args:
        aggregator (Any): Optional aggregator value to pass in

    Returns:
        timestamp (str): latest feed timestamp as hex string

    Raises:
        ValueError: If the aggregator currently holds no value
        AccountDoesNotExistError: If the account doesn&#39;t exist.
        AccountInvalidDiscriminator: If the discriminator doesn&#39;t match the IDL.
    &#34;&#34;&#34;
    async def get_latest_feed_timestamp(self, aggregator: Any) -&gt; Decimal:
        aggregator = aggregator if aggregator else await self.load_data()
        if hasattr(aggregator, &#39;latest_confirmed_round&#39;) and aggregator.latest_confirmed_round.num_success == 0:
            raise ValueError(&#39;Aggregator currently holds no value.&#39;)

        return aggregator.latest_confirmed_round.round_open_timestamp


    &#34;&#34;&#34;
    Get name of an aggregator.

    Args:
        aggregator (any): Anchor-loaded aggregator

    Returns:
        name string of the aggregator
    &#34;&#34;&#34;
    @staticmethod
    def should_report_value(value: Decimal, aggregator: Any) -&gt; bool:
        if aggregator.latestConfirmedRound and aggregator.latest_confirmed_round.num_success == 0:
            return True
        timestamp = round(int(time.time()) / 1000)
        if aggregator.start_after &gt; timestamp:
            return False
        variance_threshold = SwitchboardDecimal.sbd_to_decimal(aggregator.variance_threshold)
        latest_result = SwitchboardDecimal.sbd_to_decimal(aggregator.latest_confirmed_round.result)
        force_report_period = aggregator.force_report_period
        last_timestamp = aggregator.latest_confirmed_round.round_open_timestamp
        if last_timestamp + force_report_period &lt; timestamp:
            return True
        if value &lt; latest_result - variance_threshold:
            return True
        if value &gt; latest_result + variance_threshold:
            return True
        return False

    &#34;&#34;&#34;
    Get the individual oracle results of the latest confirmed round. 
    
    Args:
        aggregator (Any): Optional aggregator value to pass in

    Returns:
        timestamp (str): latest feed timestamp as hex string

    Raises:
        ValueError: If aggregator currently holds no value.
    &#34;&#34;&#34;
    async def get_confirmed_round_results(self, aggregator: Any) -&gt; Decimal:
        
        aggregator = aggregator if aggregator else await self.load_data()
        if hasattr(aggregator, &#39;latest_confirmed_round&#39;) and aggregator.latest_confirmed_round.num_success == 0:
            raise ValueError(&#39;Aggregator currently holds no value.&#39;)
        results: list[Any] = []
        for i in range(aggregator.oracle_request_batch_size):
            if aggregator.latest_confirmed_round.medians_filfilled[i]:
                results.append({
                    &#34;oracle_account&#34;: OracleAccount(self.program, aggregator.latest_confirmed_round.oracle_pubkeys_data[i]),
                    &#34;value&#34;: SwitchboardDecimal.sbd_to_decimal(aggregator.latest_confirmed_round.medians_data[i])
                })
        return results

    &#34;&#34;&#34;
    Get the hash of a list of OracleJobs
    
    Args:
        jobs (list[OracleJob]): list of jobs to hash

    Returns:
        hash (_Hash): hash as hex string

    Raises:
    &#34;&#34;&#34;
    @staticmethod
    def produce_job_hash(jobs: list[OracleJob]):
        hash = hashlib.sha256()
        for job in jobs:
            job_hasher = hashlib.sha256()
            job_hasher.update(job.SerializeToString())
            hash.update(job_hasher.digest())
        return hash


    &#34;&#34;&#34;
    Load and deserialize all jobs stored in this aggregator
    
    Args:
        aggregator (Any): Optional aggregator

    Returns:
        jobs (list[OracleJob]): latest feed timestamp as hex string

    Raises:
        ValueError: Failed to load feed jobs.
        AccountDoesNotExistError: If the account doesn&#39;t exist.
        AccountInvalidDiscriminator: If the discriminator doesn&#39;t match the IDL.
    &#34;&#34;&#34;
    async def load_jobs(self, aggregator: Any) -&gt; Decimal:
        coder = anchorpy.AccountsCoder(self.program.idl);
        aggregator = aggregator if aggregator else await self.load_data()
        job_accounts_raw = await anchorpy.utils.rpc.get_multiple_accounts(self.program.provider, aggregator.job_pubkeys_data)[:aggregator.job_pubkeys_size]
        if not job_accounts_raw:
            raise ValueError(&#39;Failed to load feed jobs.&#39;)
        
        # Deserialize OracleJob objects from each decoded JobAccountData 
        return [OracleJob.ParseFromString(coder.decode(job)) for job in job_accounts_raw]
        
    &#34;&#34;&#34;
    Load all job hashes for each job stored in this aggregator
    
    Args:
        aggregator (Any): Optional aggregator

    Returns:
        hashes (list[str]): hashes for each job 

    Raises:
        AccountDoesNotExistError: If the account doesn&#39;t exist.
        AccountInvalidDiscriminator: If the discriminator doesn&#39;t match the IDL.
    &#34;&#34;&#34;
    async def load_hashes(self, aggregator: Any) -&gt; Decimal:
        coder = anchorpy.AccountsCoder(self.program.idl);
        aggregator = aggregator if aggregator else await self.loadData()
        job_accounts_raw = await anchorpy.utils.rpc.get_multiple_accounts(self.program.provider, aggregator.job_pubkeys_data)[:aggregator.job_pubkeys_size]
        if not job_accounts_raw:
            raise ValueError(&#39;Failed to load feed jobs.&#39;)
        
        # get hashes from each decoded JobAccountData 
        return [coder.decode(job).hash for job in job_accounts_raw]
        
    
    &#34;&#34;&#34;
    Get the size of an AggregatorAccount on chain
    
    Returns:
        int: size of the AggregatorAccount on chain
    &#34;&#34;&#34;
    def size(self):
        return self.program.account[&#34;AggregatorAccountData&#34;].size

    &#34;&#34;&#34;
    Create and initialize the AggregatorAccount.
    
    Args:
        program (anchorpy.Program): Switchboard program representation holding connection and IDL
        params (AggregatorInitParams): init params for the aggregator

    Returns:
        AggregatorAccount
    &#34;&#34;&#34;
    @staticmethod
    async def create(program: anchorpy.Program, aggregator_init_params: AggregatorInitParams):
        aggregator_account = aggregator_init_params.keypair or Keypair.generate()
        authority = aggregator_init_params.authority or aggregator_account.public_key
        size = program.account[&#34;AggregatorAccountData&#34;].size
        state_account, state_bump = ProgramStateAccount.from_seed(program)
        state = await state_account.load_data()
        lamports = await program.provider.connection.get_minimum_balance_for_rent_exemption(size)
        await program.rpc[&#34;aggregator_init&#34;](
            {
                &#34;name&#34;: aggregator_init_params.name or bytes([0] * 32),
                &#34;metadata&#34;: aggregator_init_params.metadata or bytes([0] * 128),
                &#34;batch_size&#34;: aggregator_init_params.batch_size,
                &#34;min_oracle_results&#34;: aggregator_init_params.min_required_oracle_results,
                &#34;min_job_results&#34;: aggregator_init_params.min_required_job_results,
                &#34;variance_threshold&#34;: aggregator_init_params.variance_threshold or 0,
                &#34;force_report_period&#34;: aggregator_init_params.force_report_period or 0,
                &#34;expiration&#34;: aggregator_init_params.expiration or 0,
                &#34;state_bump&#34;: state_bump
            },
            ctx=anchorpy.Context(
                accounts={
                    &#34;aggregator&#34;: aggregator_account.public_key,
                    &#34;authority&#34;: authority,
                    &#34;queue&#34;: aggregator_init_params.queue_account.public_key,
                    &#34;author_wallet&#34;: aggregator_init_params.author_wallet or state.token_vault,
                    &#34;program_state&#34;: state_account.public_key
                },
                signers=[aggregator_account],
                instructions=[
                    create_account(
                        CreateAccountParams(
                            from_pubkey=program.provider.wallet.public_key, 
                            new_account_pubkey=aggregator_account.public_key,
                            lamports=lamports, 
                            space=size, 
                            program_id=program.program_id
                        )
                    )
                ]
            )
        )
        return AggregatorAccount(AccountParams(program=program, keypair=aggregator_account))

    &#34;&#34;&#34;
    Create and set a history buffer for the aggregator

    Args:
        program (anchorpy.Program): Switchboard program representation holding connection and IDL
        params (AggregatorSetHistoryBufferParams)

    Returns:
        TransactionSignature
    &#34;&#34;&#34;
    async def set_history_buffer(self, params: AggregatorSetHistoryBufferParams):
        buffer = Keypair.generate()
        program = self.program
        authority = params.authority or self.keypair
        HISTORY_ROW_SIZE = 28
        INSERT_IDX_SIZE = 4
        DISCRIMINATOR_SIZE = 8
        size = params.size * HISTORY_ROW_SIZE + INSERT_IDX_SIZE + DISCRIMINATOR_SIZE
        lamports = await program.provider.connection.get_minimum_balance_for_rent_exemption(size)

        await program.rpc[&#34;aggregator_set_history_buffer&#34;](
            {},
            ctx=anchorpy.Context(
                accounts={
                    &#34;aggregator&#34;: self.public_key,
                    &#34;authority&#34;: authority.public_key,
                    &#34;buffer&#34;: buffer.public_key
                },
                signers=[authority, buffer],
                instructions=[
                    create_account(
                        CreateAccountParams(
                            from_pubkey=program.provider.wallet.public_key,
                            new_account_pubkey=buffer.public_key,
                            space=size,
                            lamports=lamports,
                            program_id=program.program_id
                        )
                    )
                ]
            )
        )
    
    &#34;&#34;&#34;
    RPC to add a new job to an aggregtor to be performed on feed updates.

    Args:
        job (JobAccount): specifying another job for this aggregator to fulfill on update
        authority (Keypair | None)
    Returns:
        TransactionSignature
    &#34;&#34;&#34;
    async def add_job(self, job: JobAccount, authority: Optional[Keypair] = None) -&gt; TransactionSignature:
        authority = authority or self.keypair
        return await self.program.rpc[&#39;aggregator_add_job&#39;](
            ctx=anchorpy.Context(
                accounts={
                    &#34;aggregator&#34;: self.public_key,
                    &#34;authority&#34;: authority.public_key,
                    &#34;job&#34;: job.public_key
                },
                signers=[authority]
            )
        )
        
    &#34;&#34;&#34;
    Prevent new jobs from being added to the feed.

    Args:
        authority (Keypair | None): the current authority keypair

    Returns:
        TransactionSignature
    &#34;&#34;&#34;
    async def lock(self, authority: Optional[Keypair] = None) -&gt; TransactionSignature:
        authority = authority or self.keypair
        return await self.program.rpc[&#39;aggregator_lock&#39;](
            ctx=anchorpy.Context(
                accounts={
                    &#34;aggregator&#34;: self.public_key,
                    &#34;authority&#34;: authority.public_key,
                },
                signers=[authority]
            )
        )

    &#34;&#34;&#34;
    Change the aggregator authority

    Args:
        new_authority (Keypair): The new authority
        current_authority (Keypair | None): the current authority keypair

    Returns:
        TransactionSignature
    &#34;&#34;&#34;
    async def set_authority(self, new_authority: Keypair, current_authority: Optional[Keypair] = None) -&gt; TransactionSignature:
        current_authority = current_authority or self.keypair
        return await self.program.rpc[&#39;aggregator_set_authoirty&#39;](
            ctx=anchorpy.Context(
                accounts={
                    &#34;aggregator&#34;: self.public_key,
                    &#34;new_authority&#34;: new_authority,
                    &#34;authority&#34;: current_authority.public_key,
                },
                signers=[current_authority]
            )
        )

    &#34;&#34;&#34;
    RPC to add remove job from an aggregtor.

    Args:
        job (JobAccount): specifying job to remove
        authority (Keypair | None)
    Returns:
        TransactionSignature
    &#34;&#34;&#34;
    async def remove_job(self, job: JobAccount, authority: Optional[Keypair] = None) -&gt; TransactionSignature:
        authority = authority or self.keypair
        return await self.program.rpc[&#39;aggregator_remove_job&#39;](
            ctx=anchorpy.Context(
                accounts={
                    &#34;aggregator&#34;: self.public_key,
                    &#34;authority&#34;: authority.public_key,
                    &#34;job&#34;: job.public_key
                },
                signers=[authority]
            )
        )
    
    &#34;&#34;&#34;
    Get Index of Oracle in Aggregator

    Args:
        oracle_pubkey (PublicKey): Public key belonging to the oracle

    Returns:
        int: index of the oracle, -1 if not found
    &#34;&#34;&#34;
    async def get_oracle_index(self, oracle_pubkey: PublicKey):
        aggregator = await self.load_data()
        for i, curr_oracle_pubkey in enumerate(aggregator.current_round.oracle_pubkeys_data):
            if curr_oracle_pubkey == oracle_pubkey:
                return i
        return -1
    
    &#34;&#34;&#34;
    Save Aggregator result

    Args:
        aggregator (Any): Aggregator data
        oracle_account (OracleAccount)
        params (AggregatorSaveResultParams)

    Returns:
        TransactionSignature
    &#34;&#34;&#34;
    async def remove_job(self, aggregator: Any, oracle_account: OracleAccount, params: AggregatorSaveResultParams) -&gt; TransactionSignature:
        return await self.program.provider.send(
            tx=(
                await self.save_result_txn(
                    aggregator,
                    oracle_account,
                    params
                )
            )
        )
    
    &#34;&#34;&#34;
    RPC call for an oracle to save a result to an aggregator round.

    Args:
        aggregator (Any): Aggregator data
        oracle_account (OracleAccount)
        params (AggregatorSaveResultParams)

    Returns:
        TransactionSignature
    &#34;&#34;&#34;
    async def save_result_txn(self, aggregator: Any, oracle_account: OracleAccount, params: AggregatorSaveResultParams):
        payer_keypair = Keypair.from_secret_key(self.program.provider.wallet.payer.secret_key)
        remaining_accounts: list[PublicKey] = []
        for i in range(aggregator.oracle_request_batch_size):
            remaining_accounts.append(aggregator.current_round.oracle_pubkeys_data[i])
        for oracle in params.oracles:
            remaining_accounts.push(oracle.token_account)
        queue_pubkey = aggregator.queue_pubkey
        queue_account = OracleQueueAccount(AccountParams(program=self.program, public_key=queue_pubkey))
        lease_account, lease_bump = LeaseAccount.from_seed(
            self.program,
            queue_account,
            self
        )
        escrow = get_associated_token_address(lease_account.public_key, params.token_mint)
        feed_permission_account, feed_permission_bump = PermissionAccount.from_seed(
            self.program,
            params.queue_authority,
            queue_account.public_key,
            self.public_key
        )
        oracle_permission_account, oracle_permission_bump = PermissionAccount.from_seed(
            self.program,
            params.queue_authority,
            queue_account.public_key,
            oracle_account.public_key
        )
        program_state_account, state_bump = ProgramStateAccount.from_seed(self.program)
        digest = await self.produce_job_hash(params.jobs).digest()
        history_buffer = aggregator.history_buffer
        if history_buffer == PublicKey(&#39;11111111111111111111111111111111&#39;):
            history_buffer = self.public_key
        return self.program.transaction[&#39;aggregator_save_result&#39;](
            {
                &#34;oracle_idx&#34;: params.oracle_idx,
                &#34;error&#34;: params.error,
                &#34;value&#34;: SwitchboardDecimal.from_decimal(params.value), # @FIXME - verify that this decimal approach is correct (it very well might not be)
                &#34;jobs_checksum&#34;: digest,
                &#34;min_response&#34;: SwitchboardDecimal.from_decimal(params.min_response), # @FIXME
                &#34;max_response&#34;: SwitchboardDecimal.from_decimal(params.max_response), # @FIXME 
                &#34;feed_permission_bump&#34;: feed_permission_bump,
                &#34;oracle_permission_bump&#34;: oracle_permission_bump,
                &#34;lease_bump&#34;: lease_bump,
                &#34;state_bump&#34;: state_bump
            },
            ctx=anchorpy.Context(
                accounts={
                    &#34;aggregator&#34;: self.public_key,
                    &#34;oracle&#34;: oracle_account.public_key,
                    &#34;oracle_authority&#34;: payer_keypair.public_key,
                    &#34;oracle_queue&#34;: queue_account.public_key,
                    &#34;feed_permission&#34;: feed_permission_account.public_key,
                    &#34;oracle_permission&#34;: oracle_permission_account.public_key,
                    &#34;lease&#34;: lease_account.public_key,
                    &#34;escrow&#34;: escrow,
                    &#34;token_program&#34;: TOKEN_PROGRAM_ID,
                    &#34;program_state&#34;: program_state_account.public_key,
                    &#34;history_buffer&#34;: history_buffer
                },
                remaining_accounts=[{&#34;is_signer&#34;: False, &#34;is_writable&#34;: True, &#34;pubkey&#34;: pubkey} for pubkey in remaining_accounts]
            )
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="switchboard.aggregator.AggregatorAccount.create"><code class="name flex">
<span>async def <span class="ident">create</span></span>(<span>program:Â anchorpy.Program, aggregator_init_params:Â <a title="switchboard.aggregator.AggregatorInitParams" href="#switchboard.aggregator.AggregatorInitParams">AggregatorInitParams</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def create(program: anchorpy.Program, aggregator_init_params: AggregatorInitParams):
    aggregator_account = aggregator_init_params.keypair or Keypair.generate()
    authority = aggregator_init_params.authority or aggregator_account.public_key
    size = program.account[&#34;AggregatorAccountData&#34;].size
    state_account, state_bump = ProgramStateAccount.from_seed(program)
    state = await state_account.load_data()
    lamports = await program.provider.connection.get_minimum_balance_for_rent_exemption(size)
    await program.rpc[&#34;aggregator_init&#34;](
        {
            &#34;name&#34;: aggregator_init_params.name or bytes([0] * 32),
            &#34;metadata&#34;: aggregator_init_params.metadata or bytes([0] * 128),
            &#34;batch_size&#34;: aggregator_init_params.batch_size,
            &#34;min_oracle_results&#34;: aggregator_init_params.min_required_oracle_results,
            &#34;min_job_results&#34;: aggregator_init_params.min_required_job_results,
            &#34;variance_threshold&#34;: aggregator_init_params.variance_threshold or 0,
            &#34;force_report_period&#34;: aggregator_init_params.force_report_period or 0,
            &#34;expiration&#34;: aggregator_init_params.expiration or 0,
            &#34;state_bump&#34;: state_bump
        },
        ctx=anchorpy.Context(
            accounts={
                &#34;aggregator&#34;: aggregator_account.public_key,
                &#34;authority&#34;: authority,
                &#34;queue&#34;: aggregator_init_params.queue_account.public_key,
                &#34;author_wallet&#34;: aggregator_init_params.author_wallet or state.token_vault,
                &#34;program_state&#34;: state_account.public_key
            },
            signers=[aggregator_account],
            instructions=[
                create_account(
                    CreateAccountParams(
                        from_pubkey=program.provider.wallet.public_key, 
                        new_account_pubkey=aggregator_account.public_key,
                        lamports=lamports, 
                        space=size, 
                        program_id=program.program_id
                    )
                )
            ]
        )
    )
    return AggregatorAccount(AccountParams(program=program, keypair=aggregator_account))</code></pre>
</details>
</dd>
<dt id="switchboard.aggregator.AggregatorAccount.get_name"><code class="name flex">
<span>def <span class="ident">get_name</span></span>(<span>aggregator:Â Any) â>Â str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_name(aggregator: Any) -&gt; str:
    return  &#39;&#39;.join(map(chr, *aggregator.name)).decode(&#34;utf-8&#34;).replace(u&#34;\u0000&#34;, &#34;*&#34;).encode(&#34;utf-8&#34;)</code></pre>
</details>
</dd>
<dt id="switchboard.aggregator.AggregatorAccount.produce_job_hash"><code class="name flex">
<span>def <span class="ident">produce_job_hash</span></span>(<span>jobs:Â list[<a title="switchboard.aggregator.OracleJob" href="#switchboard.aggregator.OracleJob">OracleJob</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def produce_job_hash(jobs: list[OracleJob]):
    hash = hashlib.sha256()
    for job in jobs:
        job_hasher = hashlib.sha256()
        job_hasher.update(job.SerializeToString())
        hash.update(job_hasher.digest())
    return hash</code></pre>
</details>
</dd>
<dt id="switchboard.aggregator.AggregatorAccount.should_report_value"><code class="name flex">
<span>def <span class="ident">should_report_value</span></span>(<span>value:Â Decimal, aggregator:Â Any) â>Â bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def should_report_value(value: Decimal, aggregator: Any) -&gt; bool:
    if aggregator.latestConfirmedRound and aggregator.latest_confirmed_round.num_success == 0:
        return True
    timestamp = round(int(time.time()) / 1000)
    if aggregator.start_after &gt; timestamp:
        return False
    variance_threshold = SwitchboardDecimal.sbd_to_decimal(aggregator.variance_threshold)
    latest_result = SwitchboardDecimal.sbd_to_decimal(aggregator.latest_confirmed_round.result)
    force_report_period = aggregator.force_report_period
    last_timestamp = aggregator.latest_confirmed_round.round_open_timestamp
    if last_timestamp + force_report_period &lt; timestamp:
        return True
    if value &lt; latest_result - variance_threshold:
        return True
    if value &gt; latest_result + variance_threshold:
        return True
    return False</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="switchboard.aggregator.AggregatorAccount.add_job"><code class="name flex">
<span>async def <span class="ident">add_job</span></span>(<span>self, job:Â JobAccount, authority:Â Optional[Keypair]Â =Â None) â>Â TransactionSignature</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def add_job(self, job: JobAccount, authority: Optional[Keypair] = None) -&gt; TransactionSignature:
    authority = authority or self.keypair
    return await self.program.rpc[&#39;aggregator_add_job&#39;](
        ctx=anchorpy.Context(
            accounts={
                &#34;aggregator&#34;: self.public_key,
                &#34;authority&#34;: authority.public_key,
                &#34;job&#34;: job.public_key
            },
            signers=[authority]
        )
    )</code></pre>
</details>
</dd>
<dt id="switchboard.aggregator.AggregatorAccount.get_confirmed_round_results"><code class="name flex">
<span>async def <span class="ident">get_confirmed_round_results</span></span>(<span>self, aggregator:Â Any) â>Â decimal.Decimal</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_confirmed_round_results(self, aggregator: Any) -&gt; Decimal:
    
    aggregator = aggregator if aggregator else await self.load_data()
    if hasattr(aggregator, &#39;latest_confirmed_round&#39;) and aggregator.latest_confirmed_round.num_success == 0:
        raise ValueError(&#39;Aggregator currently holds no value.&#39;)
    results: list[Any] = []
    for i in range(aggregator.oracle_request_batch_size):
        if aggregator.latest_confirmed_round.medians_filfilled[i]:
            results.append({
                &#34;oracle_account&#34;: OracleAccount(self.program, aggregator.latest_confirmed_round.oracle_pubkeys_data[i]),
                &#34;value&#34;: SwitchboardDecimal.sbd_to_decimal(aggregator.latest_confirmed_round.medians_data[i])
            })
    return results</code></pre>
</details>
</dd>
<dt id="switchboard.aggregator.AggregatorAccount.get_latest_feed_timestamp"><code class="name flex">
<span>async def <span class="ident">get_latest_feed_timestamp</span></span>(<span>self, aggregator:Â Any) â>Â decimal.Decimal</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_latest_feed_timestamp(self, aggregator: Any) -&gt; Decimal:
    aggregator = aggregator if aggregator else await self.load_data()
    if hasattr(aggregator, &#39;latest_confirmed_round&#39;) and aggregator.latest_confirmed_round.num_success == 0:
        raise ValueError(&#39;Aggregator currently holds no value.&#39;)

    return aggregator.latest_confirmed_round.round_open_timestamp</code></pre>
</details>
</dd>
<dt id="switchboard.aggregator.AggregatorAccount.get_latest_value"><code class="name flex">
<span>async def <span class="ident">get_latest_value</span></span>(<span>self, aggregator:Â Optional[Any]Â =Â None) â>Â decimal.Decimal</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_latest_value(self, aggregator: Optional[Any] = None) -&gt; Decimal:
    aggregator = aggregator if aggregator else await self.load_data()
    if hasattr(aggregator, &#39;latest_confirmed_round&#39;) and aggregator.latest_confirmed_round.num_success == 0:
        raise ValueError(&#39;Aggregator currently holds no value.&#39;)
    return SwitchboardDecimal.sbd_to_decimal(aggregator.latest_confirmed_round.result)</code></pre>
</details>
</dd>
<dt id="switchboard.aggregator.AggregatorAccount.get_oracle_index"><code class="name flex">
<span>async def <span class="ident">get_oracle_index</span></span>(<span>self, oracle_pubkey:Â PublicKey)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_oracle_index(self, oracle_pubkey: PublicKey):
    aggregator = await self.load_data()
    for i, curr_oracle_pubkey in enumerate(aggregator.current_round.oracle_pubkeys_data):
        if curr_oracle_pubkey == oracle_pubkey:
            return i
    return -1</code></pre>
</details>
</dd>
<dt id="switchboard.aggregator.AggregatorAccount.load_data"><code class="name flex">
<span>async def <span class="ident">load_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def load_data(self):
    aggregator = await self.program.account[&#34;AggregatorAccountData&#34;].fetch(self.public_key)
    aggregator.ebuf = None
    return aggregator</code></pre>
</details>
</dd>
<dt id="switchboard.aggregator.AggregatorAccount.load_hashes"><code class="name flex">
<span>async def <span class="ident">load_hashes</span></span>(<span>self, aggregator:Â Any) â>Â decimal.Decimal</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def load_hashes(self, aggregator: Any) -&gt; Decimal:
    coder = anchorpy.AccountsCoder(self.program.idl);
    aggregator = aggregator if aggregator else await self.loadData()
    job_accounts_raw = await anchorpy.utils.rpc.get_multiple_accounts(self.program.provider, aggregator.job_pubkeys_data)[:aggregator.job_pubkeys_size]
    if not job_accounts_raw:
        raise ValueError(&#39;Failed to load feed jobs.&#39;)
    
    # get hashes from each decoded JobAccountData 
    return [coder.decode(job).hash for job in job_accounts_raw]</code></pre>
</details>
</dd>
<dt id="switchboard.aggregator.AggregatorAccount.load_history"><code class="name flex">
<span>async def <span class="ident">load_history</span></span>(<span>self, aggregator:Â AnyÂ =Â None) â>Â Any</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def load_history(self, aggregator: Any = None) -&gt; Any:

    # if aggregator data passed in - use that, else load this aggregator
    aggregator = aggregator if aggregator else await self.load_data()

    # Compare History Buffer to default public key (zeroed out)
    if (aggregator.history_buffer == 11111111111111111111111111111111):
        return []

    # Fixed AggregatorHistoryRow size
    ROW_SIZE = 28

    # Get account data
    info = await self.program.provider.connection.get_account_info(aggregator.history_buffer) 
    buffer = info.data if info else []
    if not buffer or buffer.length &lt; 12:
        return []
    
    # Read UInt32 as a Little Endian val, starting at position 8
    insert_idx: int = struct.unpack_from(&#34;&lt;L&#34;, buffer, 8)[0] * ROW_SIZE

    front = []
    tail = []

    if not isinstance(buffer, list):
        return []
    
    for i in range(13, buffer.length, ROW_SIZE):
        if i + ROW_SIZE &gt; buffer.length:
            break
        row = AggregatorHistoryRow.fromBuffer(buffer)
        if row.timestamp == 0:
            break
        if i &lt;= insert_idx:
            tail.append(row)
        else:
            front.append(row)
    return front.extend(tail)</code></pre>
</details>
</dd>
<dt id="switchboard.aggregator.AggregatorAccount.load_jobs"><code class="name flex">
<span>async def <span class="ident">load_jobs</span></span>(<span>self, aggregator:Â Any) â>Â decimal.Decimal</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def load_jobs(self, aggregator: Any) -&gt; Decimal:
    coder = anchorpy.AccountsCoder(self.program.idl);
    aggregator = aggregator if aggregator else await self.load_data()
    job_accounts_raw = await anchorpy.utils.rpc.get_multiple_accounts(self.program.provider, aggregator.job_pubkeys_data)[:aggregator.job_pubkeys_size]
    if not job_accounts_raw:
        raise ValueError(&#39;Failed to load feed jobs.&#39;)
    
    # Deserialize OracleJob objects from each decoded JobAccountData 
    return [OracleJob.ParseFromString(coder.decode(job)) for job in job_accounts_raw]</code></pre>
</details>
</dd>
<dt id="switchboard.aggregator.AggregatorAccount.lock"><code class="name flex">
<span>async def <span class="ident">lock</span></span>(<span>self, authority:Â Optional[Keypair]Â =Â None) â>Â TransactionSignature</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def lock(self, authority: Optional[Keypair] = None) -&gt; TransactionSignature:
    authority = authority or self.keypair
    return await self.program.rpc[&#39;aggregator_lock&#39;](
        ctx=anchorpy.Context(
            accounts={
                &#34;aggregator&#34;: self.public_key,
                &#34;authority&#34;: authority.public_key,
            },
            signers=[authority]
        )
    )</code></pre>
</details>
</dd>
<dt id="switchboard.aggregator.AggregatorAccount.remove_job"><code class="name flex">
<span>async def <span class="ident">remove_job</span></span>(<span>self, aggregator:Â Any, oracle_account:Â OracleAccount, params:Â <a title="switchboard.aggregator.AggregatorSaveResultParams" href="#switchboard.aggregator.AggregatorSaveResultParams">AggregatorSaveResultParams</a>) â>Â TransactionSignature</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def remove_job(self, aggregator: Any, oracle_account: OracleAccount, params: AggregatorSaveResultParams) -&gt; TransactionSignature:
    return await self.program.provider.send(
        tx=(
            await self.save_result_txn(
                aggregator,
                oracle_account,
                params
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="switchboard.aggregator.AggregatorAccount.save_result_txn"><code class="name flex">
<span>async def <span class="ident">save_result_txn</span></span>(<span>self, aggregator:Â Any, oracle_account:Â OracleAccount, params:Â <a title="switchboard.aggregator.AggregatorSaveResultParams" href="#switchboard.aggregator.AggregatorSaveResultParams">AggregatorSaveResultParams</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def save_result_txn(self, aggregator: Any, oracle_account: OracleAccount, params: AggregatorSaveResultParams):
    payer_keypair = Keypair.from_secret_key(self.program.provider.wallet.payer.secret_key)
    remaining_accounts: list[PublicKey] = []
    for i in range(aggregator.oracle_request_batch_size):
        remaining_accounts.append(aggregator.current_round.oracle_pubkeys_data[i])
    for oracle in params.oracles:
        remaining_accounts.push(oracle.token_account)
    queue_pubkey = aggregator.queue_pubkey
    queue_account = OracleQueueAccount(AccountParams(program=self.program, public_key=queue_pubkey))
    lease_account, lease_bump = LeaseAccount.from_seed(
        self.program,
        queue_account,
        self
    )
    escrow = get_associated_token_address(lease_account.public_key, params.token_mint)
    feed_permission_account, feed_permission_bump = PermissionAccount.from_seed(
        self.program,
        params.queue_authority,
        queue_account.public_key,
        self.public_key
    )
    oracle_permission_account, oracle_permission_bump = PermissionAccount.from_seed(
        self.program,
        params.queue_authority,
        queue_account.public_key,
        oracle_account.public_key
    )
    program_state_account, state_bump = ProgramStateAccount.from_seed(self.program)
    digest = await self.produce_job_hash(params.jobs).digest()
    history_buffer = aggregator.history_buffer
    if history_buffer == PublicKey(&#39;11111111111111111111111111111111&#39;):
        history_buffer = self.public_key
    return self.program.transaction[&#39;aggregator_save_result&#39;](
        {
            &#34;oracle_idx&#34;: params.oracle_idx,
            &#34;error&#34;: params.error,
            &#34;value&#34;: SwitchboardDecimal.from_decimal(params.value), # @FIXME - verify that this decimal approach is correct (it very well might not be)
            &#34;jobs_checksum&#34;: digest,
            &#34;min_response&#34;: SwitchboardDecimal.from_decimal(params.min_response), # @FIXME
            &#34;max_response&#34;: SwitchboardDecimal.from_decimal(params.max_response), # @FIXME 
            &#34;feed_permission_bump&#34;: feed_permission_bump,
            &#34;oracle_permission_bump&#34;: oracle_permission_bump,
            &#34;lease_bump&#34;: lease_bump,
            &#34;state_bump&#34;: state_bump
        },
        ctx=anchorpy.Context(
            accounts={
                &#34;aggregator&#34;: self.public_key,
                &#34;oracle&#34;: oracle_account.public_key,
                &#34;oracle_authority&#34;: payer_keypair.public_key,
                &#34;oracle_queue&#34;: queue_account.public_key,
                &#34;feed_permission&#34;: feed_permission_account.public_key,
                &#34;oracle_permission&#34;: oracle_permission_account.public_key,
                &#34;lease&#34;: lease_account.public_key,
                &#34;escrow&#34;: escrow,
                &#34;token_program&#34;: TOKEN_PROGRAM_ID,
                &#34;program_state&#34;: program_state_account.public_key,
                &#34;history_buffer&#34;: history_buffer
            },
            remaining_accounts=[{&#34;is_signer&#34;: False, &#34;is_writable&#34;: True, &#34;pubkey&#34;: pubkey} for pubkey in remaining_accounts]
        )
    )</code></pre>
</details>
</dd>
<dt id="switchboard.aggregator.AggregatorAccount.set_authority"><code class="name flex">
<span>async def <span class="ident">set_authority</span></span>(<span>self, new_authority:Â Keypair, current_authority:Â Optional[Keypair]Â =Â None) â>Â TransactionSignature</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_authority(self, new_authority: Keypair, current_authority: Optional[Keypair] = None) -&gt; TransactionSignature:
    current_authority = current_authority or self.keypair
    return await self.program.rpc[&#39;aggregator_set_authoirty&#39;](
        ctx=anchorpy.Context(
            accounts={
                &#34;aggregator&#34;: self.public_key,
                &#34;new_authority&#34;: new_authority,
                &#34;authority&#34;: current_authority.public_key,
            },
            signers=[current_authority]
        )
    )</code></pre>
</details>
</dd>
<dt id="switchboard.aggregator.AggregatorAccount.set_history_buffer"><code class="name flex">
<span>async def <span class="ident">set_history_buffer</span></span>(<span>self, params:Â <a title="switchboard.aggregator.AggregatorSetHistoryBufferParams" href="#switchboard.aggregator.AggregatorSetHistoryBufferParams">AggregatorSetHistoryBufferParams</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_history_buffer(self, params: AggregatorSetHistoryBufferParams):
    buffer = Keypair.generate()
    program = self.program
    authority = params.authority or self.keypair
    HISTORY_ROW_SIZE = 28
    INSERT_IDX_SIZE = 4
    DISCRIMINATOR_SIZE = 8
    size = params.size * HISTORY_ROW_SIZE + INSERT_IDX_SIZE + DISCRIMINATOR_SIZE
    lamports = await program.provider.connection.get_minimum_balance_for_rent_exemption(size)

    await program.rpc[&#34;aggregator_set_history_buffer&#34;](
        {},
        ctx=anchorpy.Context(
            accounts={
                &#34;aggregator&#34;: self.public_key,
                &#34;authority&#34;: authority.public_key,
                &#34;buffer&#34;: buffer.public_key
            },
            signers=[authority, buffer],
            instructions=[
                create_account(
                    CreateAccountParams(
                        from_pubkey=program.provider.wallet.public_key,
                        new_account_pubkey=buffer.public_key,
                        space=size,
                        lamports=lamports,
                        program_id=program.program_id
                    )
                )
            ]
        )
    )</code></pre>
</details>
</dd>
<dt id="switchboard.aggregator.AggregatorAccount.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def size(self):
    return self.program.account[&#34;AggregatorAccountData&#34;].size</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="switchboard.aggregator.AggregatorHistoryRow"><code class="flex name class">
<span>class <span class="ident">AggregatorHistoryRow</span></span>
<span>(</span><span>timestamp:Â int, value:Â Decimal)</span>
</code></dt>
<dd>
<div class="desc"><p>AggregatorHistoryRow is a wrapper for the row structure of elements in the aggregator history buffer.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>timestamp</code></strong> :&ensp;<code>int</code></dt>
<dd>timestamp of the aggregator result</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>Decimal</code></dt>
<dd>Aggregator value at the timestamp</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class AggregatorHistoryRow:
    &#34;&#34;&#34;AggregatorHistoryRow is a wrapper for the row structure of elements in the aggregator history buffer.
    
    Attributes:
        timestamp (int): timestamp of the aggregator result
        value (Decimal): Aggregator value at the timestamp
    &#34;&#34;&#34;
    timestamp: int
    value: Decimal
    
    &#34;&#34;&#34;
    Generate an AggregatorHistoryRow from a retrieved buffer representation

    Args:
        buf (list): Anchor-loaded buffer representation of AggregatorHistoryRow

    Returns:
        AggregatorHistoryRow
    &#34;&#34;&#34;
    @staticmethod
    def from_buffer(buf: bytes):
        timestamp: int = struct.unpack_from(&#34;&lt;L&#34;, buf[:8])[0]
        mantissa: int = struct.unpack_from(&#34;&lt;L&#34;, buf[8:24])[0]
        scale: int = struct.unpack_from(&#34;&lt;L&#34;, buf, 24)[0]
        decimal = SwitchboardDecimal.sbd_to_decimal({&#34;mantissa&#34;: mantissa, &#34;scale&#34;: scale})
        res = AggregatorHistoryRow(timestamp, decimal)
        return res</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="switchboard.aggregator.AggregatorHistoryRow.timestamp"><code class="name">var <span class="ident">timestamp</span> :Â int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="switchboard.aggregator.AggregatorHistoryRow.value"><code class="name">var <span class="ident">value</span> :Â decimal.Decimal</code></dt>
<dd>
<div class="desc"><p>Generate an AggregatorHistoryRow from a retrieved buffer representation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>buf</code></strong> :&ensp;<code>list</code></dt>
<dd>Anchor-loaded buffer representation of AggregatorHistoryRow</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>AggregatorHistoryRow</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="switchboard.aggregator.AggregatorHistoryRow.from_buffer"><code class="name flex">
<span>def <span class="ident">from_buffer</span></span>(<span>buf:Â bytes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_buffer(buf: bytes):
    timestamp: int = struct.unpack_from(&#34;&lt;L&#34;, buf[:8])[0]
    mantissa: int = struct.unpack_from(&#34;&lt;L&#34;, buf[8:24])[0]
    scale: int = struct.unpack_from(&#34;&lt;L&#34;, buf, 24)[0]
    decimal = SwitchboardDecimal.sbd_to_decimal({&#34;mantissa&#34;: mantissa, &#34;scale&#34;: scale})
    res = AggregatorHistoryRow(timestamp, decimal)
    return res</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="switchboard.aggregator.AggregatorInitParams"><code class="flex name class">
<span>class <span class="ident">AggregatorInitParams</span></span>
<span>(</span><span>batch_size:Â ForwardRef('int')Â =Â _tuplegetter(0, 'Alias for field number 0'), min_required_oracle_results:Â ForwardRef('int')Â =Â _tuplegetter(1, 'Alias for field number 1'), min_required_job_results:Â ForwardRef('int')Â =Â _tuplegetter(2, 'Alias for field number 2'), min_update_delay_seconds:Â ForwardRef('int')Â =Â _tuplegetter(3, 'Alias for field number 3'), queue_account:Â ForwardRef('OracleQueueAccount')Â =Â _tuplegetter(4, 'Alias for field number 4'), name:Â ForwardRef('bytes')Â =Â _tuplegetter(5, 'Alias for field number 5'), metadata:Â ForwardRef('bytes')Â =Â _tuplegetter(6, 'Alias for field number 6'), start_after:Â ForwardRef('int')Â =Â _tuplegetter(7, 'Alias for field number 7'), variance_threshold:Â ForwardRef('Decimal')Â =Â _tuplegetter(8, 'Alias for field number 8'), force_report_period:Â ForwardRef('int')Â =Â _tuplegetter(9, 'Alias for field number 9'), expiration:Â ForwardRef('int')Â =Â _tuplegetter(10, 'Alias for field number 10'), keypair:Â ForwardRef('Keypair')Â =Â _tuplegetter(11, 'Alias for field number 11'), author_wallet:Â ForwardRef('PublicKey')Â =Â _tuplegetter(12, 'Alias for field number 12'), authority:Â ForwardRef('PublicKey')Â =Â _tuplegetter(13, 'Alias for field number 13'))</span>
</code></dt>
<dd>
<div class="desc"><p>Number of oracles to request on aggregator update.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class AggregatorInitParams(NamedTuple):
    &#34;&#34;&#34;Number of oracles to request on aggregator update.&#34;&#34;&#34;
    batch_size: int

    &#34;&#34;&#34;Minimum number of oracle responses required before a round is validated.&#34;&#34;&#34;
    min_required_oracle_results: int

    &#34;&#34;&#34;Minimum number of seconds required between aggregator rounds.&#34;&#34;&#34;
    min_required_job_results: int

    &#34;&#34;&#34;Minimum number of seconds required between aggregator rounds.&#34;&#34;&#34;
    min_update_delay_seconds: int

    &#34;&#34;&#34;The queue to which this aggregator will be linked&#34;&#34;&#34;
    queue_account: OracleQueueAccount
 
    &#34;&#34;&#34;Name of the aggregator to store on-chain.&#34;&#34;&#34;
    name: bytes = None

    &#34;&#34;&#34;Metadata of the aggregator to store on-chain.&#34;&#34;&#34;
    metadata: bytes = None

    &#34;&#34;&#34;unix_timestamp for which no feed update will occur before.&#34;&#34;&#34;
    start_after: int = None

    &#34;&#34;&#34;
    Change percentage required between a previous round and the current round.
    If variance percentage is not met, reject new oracle responses.
    &#34;&#34;&#34;
    variance_threshold: Decimal = None

    &#34;&#34;&#34;
    Number of seconds for which, even if the variance threshold is not passed,
    accept new responses from oracles.
    &#34;&#34;&#34;
    force_report_period: int = None

    &#34;&#34;&#34;
    unix_timestamp after which funds may be withdrawn from the aggregator.
    null/undefined/0 means the feed has no expiration.
    &#34;&#34;&#34;
    expiration: int = None

    &#34;&#34;&#34;
    An optional wallet for receiving kickbacks from job usage in feeds.
    Defaults to token vault.
    &#34;&#34;&#34;
    keypair: Keypair = None
    
    &#34;&#34;&#34;
    An optional wallet for receiving kickbacks from job usage in feeds.
    Defaults to token vault.
    &#34;&#34;&#34;
    author_wallet: PublicKey = None

    &#34;&#34;&#34;
    If included, this keypair will be the aggregator authority rather than
    the aggregator keypair.
    &#34;&#34;&#34;
    authority: PublicKey = None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="switchboard.aggregator.AggregatorInitParams.author_wallet"><code class="name">var <span class="ident">author_wallet</span> :Â solana.publickey.PublicKey</code></dt>
<dd>
<div class="desc"><p>If included, this keypair will be the aggregator authority rather than
the aggregator keypair.</p></div>
</dd>
<dt id="switchboard.aggregator.AggregatorInitParams.authority"><code class="name">var <span class="ident">authority</span> :Â solana.publickey.PublicKey</code></dt>
<dd>
<div class="desc"><p>Alias for field number 13</p></div>
</dd>
<dt id="switchboard.aggregator.AggregatorInitParams.batch_size"><code class="name">var <span class="ident">batch_size</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Minimum number of oracle responses required before a round is validated.</p></div>
</dd>
<dt id="switchboard.aggregator.AggregatorInitParams.expiration"><code class="name">var <span class="ident">expiration</span> :Â int</code></dt>
<dd>
<div class="desc"><p>An optional wallet for receiving kickbacks from job usage in feeds.
Defaults to token vault.</p></div>
</dd>
<dt id="switchboard.aggregator.AggregatorInitParams.force_report_period"><code class="name">var <span class="ident">force_report_period</span> :Â int</code></dt>
<dd>
<div class="desc"><p>unix_timestamp after which funds may be withdrawn from the aggregator.
null/undefined/0 means the feed has no expiration.</p></div>
</dd>
<dt id="switchboard.aggregator.AggregatorInitParams.keypair"><code class="name">var <span class="ident">keypair</span> :Â solana.keypair.Keypair</code></dt>
<dd>
<div class="desc"><p>An optional wallet for receiving kickbacks from job usage in feeds.
Defaults to token vault.</p></div>
</dd>
<dt id="switchboard.aggregator.AggregatorInitParams.metadata"><code class="name">var <span class="ident">metadata</span> :Â bytes</code></dt>
<dd>
<div class="desc"><p>unix_timestamp for which no feed update will occur before.</p></div>
</dd>
<dt id="switchboard.aggregator.AggregatorInitParams.min_required_job_results"><code class="name">var <span class="ident">min_required_job_results</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Minimum number of seconds required between aggregator rounds.</p></div>
</dd>
<dt id="switchboard.aggregator.AggregatorInitParams.min_required_oracle_results"><code class="name">var <span class="ident">min_required_oracle_results</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Minimum number of seconds required between aggregator rounds.</p></div>
</dd>
<dt id="switchboard.aggregator.AggregatorInitParams.min_update_delay_seconds"><code class="name">var <span class="ident">min_update_delay_seconds</span> :Â int</code></dt>
<dd>
<div class="desc"><p>The queue to which this aggregator will be linked</p></div>
</dd>
<dt id="switchboard.aggregator.AggregatorInitParams.name"><code class="name">var <span class="ident">name</span> :Â bytes</code></dt>
<dd>
<div class="desc"><p>Metadata of the aggregator to store on-chain.</p></div>
</dd>
<dt id="switchboard.aggregator.AggregatorInitParams.queue_account"><code class="name">var <span class="ident">queue_account</span> :Â <a title="switchboard.oraclequeue.OracleQueueAccount" href="oraclequeue.html#switchboard.oraclequeue.OracleQueueAccount">OracleQueueAccount</a></code></dt>
<dd>
<div class="desc"><p>Name of the aggregator to store on-chain.</p></div>
</dd>
<dt id="switchboard.aggregator.AggregatorInitParams.start_after"><code class="name">var <span class="ident">start_after</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Change percentage required between a previous round and the current round.
If variance percentage is not met, reject new oracle responses.</p></div>
</dd>
<dt id="switchboard.aggregator.AggregatorInitParams.variance_threshold"><code class="name">var <span class="ident">variance_threshold</span> :Â decimal.Decimal</code></dt>
<dd>
<div class="desc"><p>Number of seconds for which, even if the variance threshold is not passed,
accept new responses from oracles.</p></div>
</dd>
</dl>
</dd>
<dt id="switchboard.aggregator.AggregatorOpenRoundParams"><code class="flex name class">
<span>class <span class="ident">AggregatorOpenRoundParams</span></span>
<span>(</span><span>oracle_queue_account:Â OracleQueueAccount, payout_wallet:Â PublicKey)</span>
</code></dt>
<dd>
<div class="desc"><p>The oracle queue from which oracles are assigned this update.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class AggregatorOpenRoundParams:

    &#34;&#34;&#34;The oracle queue from which oracles are assigned this update.&#34;&#34;&#34;
    oracle_queue_account: OracleQueueAccount
    
    &#34;&#34;&#34;The token wallet which will receive rewards for calling update on this feed.&#34;&#34;&#34;
    payout_wallet: PublicKey</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="switchboard.aggregator.AggregatorOpenRoundParams.oracle_queue_account"><code class="name">var <span class="ident">oracle_queue_account</span> :Â <a title="switchboard.oraclequeue.OracleQueueAccount" href="oraclequeue.html#switchboard.oraclequeue.OracleQueueAccount">OracleQueueAccount</a></code></dt>
<dd>
<div class="desc"><p>The token wallet which will receive rewards for calling update on this feed.</p></div>
</dd>
<dt id="switchboard.aggregator.AggregatorOpenRoundParams.payout_wallet"><code class="name">var <span class="ident">payout_wallet</span> :Â solana.publickey.PublicKey</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="switchboard.aggregator.AggregatorSaveResultParams"><code class="flex name class">
<span>class <span class="ident">AggregatorSaveResultParams</span></span>
<span>(</span><span>oracle_idx:Â int, error:Â bool, value:Â Decimal, min_response:Â Decimal, max_response:Â Decimal, jobs:Â list[<a title="switchboard.aggregator.OracleJob" href="#switchboard.aggregator.OracleJob">OracleJob</a>], queue_authority:Â PublicKey, token_mint:Â PublicKey, oracles:Â list[Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Index in the list of oracles in the aggregator assigned to this round update.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class AggregatorSaveResultParams:

    &#34;&#34;&#34;Index in the list of oracles in the aggregator assigned to this round update.&#34;&#34;&#34;
    oracle_idx: int

    &#34;&#34;&#34;Reports that an error occured and the oracle could not send a value.&#34;&#34;&#34;
    error: bool

    &#34;&#34;&#34;Value the oracle is responding with for this update.&#34;&#34;&#34;
    value: Decimal

    &#34;&#34;&#34;
    The minimum value this oracle has seen this round for the jobs listed in the
    aggregator.
    &#34;&#34;&#34;
    min_response: Decimal

    &#34;&#34;&#34;
    The maximum value this oracle has seen this round for the jobs listed in the
    aggregator.
    &#34;&#34;&#34;
    max_response: Decimal

    &#34;&#34;&#34;List of OracleJobs that were performed to produce this result&#34;&#34;&#34;
    jobs: list[OracleJob]

    &#34;&#34;&#34;Authority of the queue the aggregator is attached to&#34;&#34;&#34;
    queue_authority: PublicKey

    &#34;&#34;&#34;Program token mint&#34;&#34;&#34;
    token_mint: PublicKey

    &#34;&#34;&#34;List of parsed oracles&#34;&#34;&#34;
    oracles: list[Any]</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="switchboard.aggregator.AggregatorSaveResultParams.error"><code class="name">var <span class="ident">error</span> :Â bool</code></dt>
<dd>
<div class="desc"><p>Value the oracle is responding with for this update.</p></div>
</dd>
<dt id="switchboard.aggregator.AggregatorSaveResultParams.jobs"><code class="name">var <span class="ident">jobs</span> :Â list</code></dt>
<dd>
<div class="desc"><p>Authority of the queue the aggregator is attached to</p></div>
</dd>
<dt id="switchboard.aggregator.AggregatorSaveResultParams.max_response"><code class="name">var <span class="ident">max_response</span> :Â decimal.Decimal</code></dt>
<dd>
<div class="desc"><p>List of OracleJobs that were performed to produce this result</p></div>
</dd>
<dt id="switchboard.aggregator.AggregatorSaveResultParams.min_response"><code class="name">var <span class="ident">min_response</span> :Â decimal.Decimal</code></dt>
<dd>
<div class="desc"><p>The maximum value this oracle has seen this round for the jobs listed in the
aggregator.</p></div>
</dd>
<dt id="switchboard.aggregator.AggregatorSaveResultParams.oracle_idx"><code class="name">var <span class="ident">oracle_idx</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Reports that an error occured and the oracle could not send a value.</p></div>
</dd>
<dt id="switchboard.aggregator.AggregatorSaveResultParams.oracles"><code class="name">var <span class="ident">oracles</span> :Â list</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="switchboard.aggregator.AggregatorSaveResultParams.queue_authority"><code class="name">var <span class="ident">queue_authority</span> :Â solana.publickey.PublicKey</code></dt>
<dd>
<div class="desc"><p>Program token mint</p></div>
</dd>
<dt id="switchboard.aggregator.AggregatorSaveResultParams.token_mint"><code class="name">var <span class="ident">token_mint</span> :Â solana.publickey.PublicKey</code></dt>
<dd>
<div class="desc"><p>List of parsed oracles</p></div>
</dd>
<dt id="switchboard.aggregator.AggregatorSaveResultParams.value"><code class="name">var <span class="ident">value</span> :Â decimal.Decimal</code></dt>
<dd>
<div class="desc"><p>The minimum value this oracle has seen this round for the jobs listed in the
aggregator.</p></div>
</dd>
</dl>
</dd>
<dt id="switchboard.aggregator.AggregatorSetHistoryBufferParams"><code class="flex name class">
<span>class <span class="ident">AggregatorSetHistoryBufferParams</span></span>
<span>(</span><span>size:Â int, authority:Â KeypairÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Number of elements for the history buffer to fit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class AggregatorSetHistoryBufferParams:
    
    &#34;&#34;&#34;Number of elements for the history buffer to fit&#34;&#34;&#34;
    size: int

    &#34;&#34;&#34;Authority keypair for the aggregator&#34;&#34;&#34;
    authority: Keypair = None</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="switchboard.aggregator.AggregatorSetHistoryBufferParams.authority"><code class="name">var <span class="ident">authority</span> :Â solana.keypair.Keypair</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="switchboard.aggregator.AggregatorSetHistoryBufferParams.size"><code class="name">var <span class="ident">size</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Authority keypair for the aggregator</p></div>
</dd>
</dl>
</dd>
<dt id="switchboard.aggregator.OracleJob"><code class="flex name class">
<span>class <span class="ident">OracleJob</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>google.protobuf.pyext._message.CMessage</li>
<li>google.protobuf.message.Message</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="switchboard.aggregator.OracleJob.AddTask"><code class="name">var <span class="ident">AddTask</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="switchboard.aggregator.OracleJob.ConditionalTask"><code class="name">var <span class="ident">ConditionalTask</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="switchboard.aggregator.OracleJob.DESCRIPTOR"><code class="name">var <span class="ident">DESCRIPTOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="switchboard.aggregator.OracleJob.DivideTask"><code class="name">var <span class="ident">DivideTask</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="switchboard.aggregator.OracleJob.HttpTask"><code class="name">var <span class="ident">HttpTask</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="switchboard.aggregator.OracleJob.JsonParseTask"><code class="name">var <span class="ident">JsonParseTask</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="switchboard.aggregator.OracleJob.LpExchangeRateTask"><code class="name">var <span class="ident">LpExchangeRateTask</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="switchboard.aggregator.OracleJob.LpTokenPriceTask"><code class="name">var <span class="ident">LpTokenPriceTask</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="switchboard.aggregator.OracleJob.MaxTask"><code class="name">var <span class="ident">MaxTask</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="switchboard.aggregator.OracleJob.MeanTask"><code class="name">var <span class="ident">MeanTask</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="switchboard.aggregator.OracleJob.MedianTask"><code class="name">var <span class="ident">MedianTask</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="switchboard.aggregator.OracleJob.MultiplyTask"><code class="name">var <span class="ident">MultiplyTask</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="switchboard.aggregator.OracleJob.RegexExtractTask"><code class="name">var <span class="ident">RegexExtractTask</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="switchboard.aggregator.OracleJob.SerumSwapTask"><code class="name">var <span class="ident">SerumSwapTask</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="switchboard.aggregator.OracleJob.SubtractTask"><code class="name">var <span class="ident">SubtractTask</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="switchboard.aggregator.OracleJob.Task"><code class="name">var <span class="ident">Task</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="switchboard.aggregator.OracleJob.TwapTask"><code class="name">var <span class="ident">TwapTask</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="switchboard.aggregator.OracleJob.ValueTask"><code class="name">var <span class="ident">ValueTask</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="switchboard.aggregator.OracleJob.WebsocketTask"><code class="name">var <span class="ident">WebsocketTask</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="switchboard.aggregator.OracleJob.XStepPriceTask"><code class="name">var <span class="ident">XStepPriceTask</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="switchboard.aggregator.OracleJob.tasks"><code class="name">var <span class="ident">tasks</span></code></dt>
<dd>
<div class="desc"><p>Field OracleJob.tasks</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="switchboard" href="index.html">switchboard</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="switchboard.aggregator.AggregatorAccount" href="#switchboard.aggregator.AggregatorAccount">AggregatorAccount</a></code></h4>
<ul class="">
<li><code><a title="switchboard.aggregator.AggregatorAccount.add_job" href="#switchboard.aggregator.AggregatorAccount.add_job">add_job</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorAccount.create" href="#switchboard.aggregator.AggregatorAccount.create">create</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorAccount.get_confirmed_round_results" href="#switchboard.aggregator.AggregatorAccount.get_confirmed_round_results">get_confirmed_round_results</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorAccount.get_latest_feed_timestamp" href="#switchboard.aggregator.AggregatorAccount.get_latest_feed_timestamp">get_latest_feed_timestamp</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorAccount.get_latest_value" href="#switchboard.aggregator.AggregatorAccount.get_latest_value">get_latest_value</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorAccount.get_name" href="#switchboard.aggregator.AggregatorAccount.get_name">get_name</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorAccount.get_oracle_index" href="#switchboard.aggregator.AggregatorAccount.get_oracle_index">get_oracle_index</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorAccount.load_data" href="#switchboard.aggregator.AggregatorAccount.load_data">load_data</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorAccount.load_hashes" href="#switchboard.aggregator.AggregatorAccount.load_hashes">load_hashes</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorAccount.load_history" href="#switchboard.aggregator.AggregatorAccount.load_history">load_history</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorAccount.load_jobs" href="#switchboard.aggregator.AggregatorAccount.load_jobs">load_jobs</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorAccount.lock" href="#switchboard.aggregator.AggregatorAccount.lock">lock</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorAccount.produce_job_hash" href="#switchboard.aggregator.AggregatorAccount.produce_job_hash">produce_job_hash</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorAccount.remove_job" href="#switchboard.aggregator.AggregatorAccount.remove_job">remove_job</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorAccount.save_result_txn" href="#switchboard.aggregator.AggregatorAccount.save_result_txn">save_result_txn</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorAccount.set_authority" href="#switchboard.aggregator.AggregatorAccount.set_authority">set_authority</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorAccount.set_history_buffer" href="#switchboard.aggregator.AggregatorAccount.set_history_buffer">set_history_buffer</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorAccount.should_report_value" href="#switchboard.aggregator.AggregatorAccount.should_report_value">should_report_value</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorAccount.size" href="#switchboard.aggregator.AggregatorAccount.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="switchboard.aggregator.AggregatorHistoryRow" href="#switchboard.aggregator.AggregatorHistoryRow">AggregatorHistoryRow</a></code></h4>
<ul class="">
<li><code><a title="switchboard.aggregator.AggregatorHistoryRow.from_buffer" href="#switchboard.aggregator.AggregatorHistoryRow.from_buffer">from_buffer</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorHistoryRow.timestamp" href="#switchboard.aggregator.AggregatorHistoryRow.timestamp">timestamp</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorHistoryRow.value" href="#switchboard.aggregator.AggregatorHistoryRow.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="switchboard.aggregator.AggregatorInitParams" href="#switchboard.aggregator.AggregatorInitParams">AggregatorInitParams</a></code></h4>
<ul class="">
<li><code><a title="switchboard.aggregator.AggregatorInitParams.author_wallet" href="#switchboard.aggregator.AggregatorInitParams.author_wallet">author_wallet</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorInitParams.authority" href="#switchboard.aggregator.AggregatorInitParams.authority">authority</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorInitParams.batch_size" href="#switchboard.aggregator.AggregatorInitParams.batch_size">batch_size</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorInitParams.expiration" href="#switchboard.aggregator.AggregatorInitParams.expiration">expiration</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorInitParams.force_report_period" href="#switchboard.aggregator.AggregatorInitParams.force_report_period">force_report_period</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorInitParams.keypair" href="#switchboard.aggregator.AggregatorInitParams.keypair">keypair</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorInitParams.metadata" href="#switchboard.aggregator.AggregatorInitParams.metadata">metadata</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorInitParams.min_required_job_results" href="#switchboard.aggregator.AggregatorInitParams.min_required_job_results">min_required_job_results</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorInitParams.min_required_oracle_results" href="#switchboard.aggregator.AggregatorInitParams.min_required_oracle_results">min_required_oracle_results</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorInitParams.min_update_delay_seconds" href="#switchboard.aggregator.AggregatorInitParams.min_update_delay_seconds">min_update_delay_seconds</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorInitParams.name" href="#switchboard.aggregator.AggregatorInitParams.name">name</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorInitParams.queue_account" href="#switchboard.aggregator.AggregatorInitParams.queue_account">queue_account</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorInitParams.start_after" href="#switchboard.aggregator.AggregatorInitParams.start_after">start_after</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorInitParams.variance_threshold" href="#switchboard.aggregator.AggregatorInitParams.variance_threshold">variance_threshold</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="switchboard.aggregator.AggregatorOpenRoundParams" href="#switchboard.aggregator.AggregatorOpenRoundParams">AggregatorOpenRoundParams</a></code></h4>
<ul class="">
<li><code><a title="switchboard.aggregator.AggregatorOpenRoundParams.oracle_queue_account" href="#switchboard.aggregator.AggregatorOpenRoundParams.oracle_queue_account">oracle_queue_account</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorOpenRoundParams.payout_wallet" href="#switchboard.aggregator.AggregatorOpenRoundParams.payout_wallet">payout_wallet</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="switchboard.aggregator.AggregatorSaveResultParams" href="#switchboard.aggregator.AggregatorSaveResultParams">AggregatorSaveResultParams</a></code></h4>
<ul class="two-column">
<li><code><a title="switchboard.aggregator.AggregatorSaveResultParams.error" href="#switchboard.aggregator.AggregatorSaveResultParams.error">error</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorSaveResultParams.jobs" href="#switchboard.aggregator.AggregatorSaveResultParams.jobs">jobs</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorSaveResultParams.max_response" href="#switchboard.aggregator.AggregatorSaveResultParams.max_response">max_response</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorSaveResultParams.min_response" href="#switchboard.aggregator.AggregatorSaveResultParams.min_response">min_response</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorSaveResultParams.oracle_idx" href="#switchboard.aggregator.AggregatorSaveResultParams.oracle_idx">oracle_idx</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorSaveResultParams.oracles" href="#switchboard.aggregator.AggregatorSaveResultParams.oracles">oracles</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorSaveResultParams.queue_authority" href="#switchboard.aggregator.AggregatorSaveResultParams.queue_authority">queue_authority</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorSaveResultParams.token_mint" href="#switchboard.aggregator.AggregatorSaveResultParams.token_mint">token_mint</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorSaveResultParams.value" href="#switchboard.aggregator.AggregatorSaveResultParams.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="switchboard.aggregator.AggregatorSetHistoryBufferParams" href="#switchboard.aggregator.AggregatorSetHistoryBufferParams">AggregatorSetHistoryBufferParams</a></code></h4>
<ul class="">
<li><code><a title="switchboard.aggregator.AggregatorSetHistoryBufferParams.authority" href="#switchboard.aggregator.AggregatorSetHistoryBufferParams.authority">authority</a></code></li>
<li><code><a title="switchboard.aggregator.AggregatorSetHistoryBufferParams.size" href="#switchboard.aggregator.AggregatorSetHistoryBufferParams.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="switchboard.aggregator.OracleJob" href="#switchboard.aggregator.OracleJob">OracleJob</a></code></h4>
<ul class="two-column">
<li><code><a title="switchboard.aggregator.OracleJob.AddTask" href="#switchboard.aggregator.OracleJob.AddTask">AddTask</a></code></li>
<li><code><a title="switchboard.aggregator.OracleJob.ConditionalTask" href="#switchboard.aggregator.OracleJob.ConditionalTask">ConditionalTask</a></code></li>
<li><code><a title="switchboard.aggregator.OracleJob.DESCRIPTOR" href="#switchboard.aggregator.OracleJob.DESCRIPTOR">DESCRIPTOR</a></code></li>
<li><code><a title="switchboard.aggregator.OracleJob.DivideTask" href="#switchboard.aggregator.OracleJob.DivideTask">DivideTask</a></code></li>
<li><code><a title="switchboard.aggregator.OracleJob.HttpTask" href="#switchboard.aggregator.OracleJob.HttpTask">HttpTask</a></code></li>
<li><code><a title="switchboard.aggregator.OracleJob.JsonParseTask" href="#switchboard.aggregator.OracleJob.JsonParseTask">JsonParseTask</a></code></li>
<li><code><a title="switchboard.aggregator.OracleJob.LpExchangeRateTask" href="#switchboard.aggregator.OracleJob.LpExchangeRateTask">LpExchangeRateTask</a></code></li>
<li><code><a title="switchboard.aggregator.OracleJob.LpTokenPriceTask" href="#switchboard.aggregator.OracleJob.LpTokenPriceTask">LpTokenPriceTask</a></code></li>
<li><code><a title="switchboard.aggregator.OracleJob.MaxTask" href="#switchboard.aggregator.OracleJob.MaxTask">MaxTask</a></code></li>
<li><code><a title="switchboard.aggregator.OracleJob.MeanTask" href="#switchboard.aggregator.OracleJob.MeanTask">MeanTask</a></code></li>
<li><code><a title="switchboard.aggregator.OracleJob.MedianTask" href="#switchboard.aggregator.OracleJob.MedianTask">MedianTask</a></code></li>
<li><code><a title="switchboard.aggregator.OracleJob.MultiplyTask" href="#switchboard.aggregator.OracleJob.MultiplyTask">MultiplyTask</a></code></li>
<li><code><a title="switchboard.aggregator.OracleJob.RegexExtractTask" href="#switchboard.aggregator.OracleJob.RegexExtractTask">RegexExtractTask</a></code></li>
<li><code><a title="switchboard.aggregator.OracleJob.SerumSwapTask" href="#switchboard.aggregator.OracleJob.SerumSwapTask">SerumSwapTask</a></code></li>
<li><code><a title="switchboard.aggregator.OracleJob.SubtractTask" href="#switchboard.aggregator.OracleJob.SubtractTask">SubtractTask</a></code></li>
<li><code><a title="switchboard.aggregator.OracleJob.Task" href="#switchboard.aggregator.OracleJob.Task">Task</a></code></li>
<li><code><a title="switchboard.aggregator.OracleJob.TwapTask" href="#switchboard.aggregator.OracleJob.TwapTask">TwapTask</a></code></li>
<li><code><a title="switchboard.aggregator.OracleJob.ValueTask" href="#switchboard.aggregator.OracleJob.ValueTask">ValueTask</a></code></li>
<li><code><a title="switchboard.aggregator.OracleJob.WebsocketTask" href="#switchboard.aggregator.OracleJob.WebsocketTask">WebsocketTask</a></code></li>
<li><code><a title="switchboard.aggregator.OracleJob.XStepPriceTask" href="#switchboard.aggregator.OracleJob.XStepPriceTask">XStepPriceTask</a></code></li>
<li><code><a title="switchboard.aggregator.OracleJob.tasks" href="#switchboard.aggregator.OracleJob.tasks">tasks</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>